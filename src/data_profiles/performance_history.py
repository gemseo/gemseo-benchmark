# -*- coding: utf-8 -*-
# Copyright 2021 IRT Saint ExupÃ©ry, https://www.irt-saintexupery.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License version 3 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

# Contributors:
#    INITIAL AUTHORS - initial API and implementation and/or initial
#                           documentation
#        :author: Benoit Pauwels
#    OTHER AUTHORS   - MACROSCOPIC CHANGES
"""Class that generates performance measures out of data generated by an algorithm.

Iterative algorithms that solve, for example, optimization problems or equations
produce histories of data such as the value of the objective to minimize,
or the size of the equation residual, at each iteration.
The best value obtained up until each iteration can be generated out of this data.
Here we call "performance history" the history of the best values obtained up until
each iteration.

Infeasible data can be discarded based upon histories of infeasibility measures or
boolean feasibility statuses.

Performance histories can be used to generate target values for a problem,
or to generate the data profile of an algorithm.
"""
from functools import reduce
from json import dump, load
from math import ceil
from pathlib import Path
from typing import Iterable, Iterator, List, Optional, Tuple, Union

from numpy import inf

from data_profiles.history_item import HistoryItem


class PerformanceHistory(object):
    """A history of performance measures generated by an algorithm."""
    PERFORMANCE = "performance"
    INFEASIBILITY = "infeasibility"

    def __init__(
            self,
            objective_values=None,  # type: Optional[List[float]]
            infeasibility_measures=None,  # type: Optional[List[float]]
            feasibility=None  # type: Optional[List[bool]]
    ):  # type: (...) -> None
        """
        Args:
            objective_values: The history of the quantity to be minimized.
            infeasibility_measures: The history of infeasibility measures.
                An infeasibility measure is a non-negative real number representing
                the gap between the design and the feasible space,
                a zero value meaning feasibility.
                If no infeasibility measures are passed but feasibility statuses are
                passed then the infeasibility measures are set to zero in case of
                feasibility, and set to infinity otherwise.
                If neither infeasibility measures nor feasibility statuses are passed
                then every infeasibility measure is set to zero.
            feasibility: The history of (boolean) feasibility.
                If infeasibility measures are passed then the boolean feasibility
                statuses are disregarded.

        Raises:
            ValueError: If the lengths of the histories do not match.
        """
        if objective_values is None:
            objective_values = []
        if infeasibility_measures is not None:
            if len(infeasibility_measures) != len(objective_values):
                raise ValueError("The objective history and the infeasibility measures "
                                 "history must have same length.")
        elif feasibility is not None:
            if len(feasibility) != len(objective_values):
                raise ValueError("The objective history and the feasibility history "
                                 "must have same length.")
            infeasibility_measures = [0.0 if a_feas else inf for a_feas in feasibility]
        else:
            infeasibility_measures = [0.0] * len(objective_values)
        self.history_items = [
            HistoryItem(a_value, a_measure) for a_value, a_measure
            in zip(objective_values, infeasibility_measures)
        ]

    @property
    def objective_values(self):  # type: (...) -> List[float]
        """Return the objective values."""
        return [an_item.objective_value for an_item in self.history_items]

    @property
    def infeasibility_measures(self):  # type: (...) -> List[float]
        """Return the infeasibility measures."""
        return [an_item.infeasibility_measure for an_item in self.history_items]

    @property
    def history_items(self):  # type: (...) -> List[HistoryItem]
        """Return the history items."""
        return self._items

    @history_items.setter
    def history_items(
            self,
            history_items,  # type: Iterable[HistoryItem]
    ):  # type: (...) -> None
        """
        Raises:
            TypeError: If an item is not of type HistoryItem.
        """
        for an_item in history_items:
            if not isinstance(an_item, HistoryItem):
                raise TypeError("History items must be of type HistoryItem")
        self._items = list(history_items)

    def __len__(self):  # type: (...) -> int
        """Return the length of the history."""
        return len(self._items)

    def __iter__(self):  # type: (...) -> Iterator[HistoryItem]
        """Return the history items as an iterator."""
        return iter(self._items)

    def __getitem__(self, item):  # type: (...) -> HistoryItem
        """Return the required history item."""
        return self._items[item]

    def __str__(self):  # type: (...) -> str
        # FIXME: repr ?
        return str(self.to_list())

    def compute_cumulated_minimum(self):  # type: (...) -> PerformanceHistory
        """Return the history of the cumulated minimum.

        Returns:
            The history of the cumulated minimum.
        """
        minima = [reduce(min, self._items[:i + 1]) for i in range(len(self))]
        minimum_history = PerformanceHistory()
        minimum_history.history_items = minima
        return minimum_history

    def to_list(self):  # type: (...) -> List[Tuple[float, float]]
        """Return the performance history as a list of 2-tuples.

        Returns:
            The performance history as a list.
        """
        return [
            (an_item.objective_value, an_item.infeasibility_measure)
            for an_item in self._items
        ]

    def _compute_median(self):  # type: (...) -> HistoryItem
        """Return the median of the history of performance values.

        Returns:
            The median of the history of performance values.
        """
        return sorted(self._items)[ceil(len(self) // 2)]

    @staticmethod
    def compute_median_history(
            histories  # type: Iterable[PerformanceHistory]
    ):  # type: (...) -> PerformanceHistory
        """Return the history of the median of several performance histories.

        Args:
            histories: The performance histories

        Returns:
            The median history.
        """
        medians_list = list()
        for snapshot in zip(*[a_hist.history_items for a_hist in histories]):
            snapshot_as_hist = PerformanceHistory()
            snapshot_as_hist.history_items = snapshot
            median = snapshot_as_hist._compute_median()
            medians_list.append(median)
        median_history = PerformanceHistory()
        median_history.history_items = medians_list
        return median_history

    def remove_leading_infeasible(self):  # type: (...) -> PerformanceHistory
        """Return the history starting from the first feasible item.

        Returns:
            The truncated performance history.
        """
        first_feasible = None
        for an_index, an_item in enumerate(self):
            if an_item.infeasibility_measure == 0.0:
                first_feasible = an_index
                break
        if first_feasible is None:
            truncated_history = PerformanceHistory()
        else:
            truncated_history = PerformanceHistory()
            truncated_history.history_items = self.history_items[first_feasible:]
        return truncated_history

    def save_to_file(
            self,
            file_path,  # type: Union[str, Path]
    ):  # type: (...) -> None
        """Save the performance history in a file.

        Args:
            file_path: The path where to write the file.
        """
        data = [
            dict([
                (PerformanceHistory.PERFORMANCE, an_item.objective_value),
                (PerformanceHistory.INFEASIBILITY, an_item.infeasibility_measure)
            ])
            for an_item in self.history_items
        ]
        with Path(file_path).open("w") as the_file:
            dump(data, the_file, indent=4)

    @staticmethod
    def load_from_file(
            file_path,  # type: Union[str, Path]
    ):  # type: (...) -> PerformanceHistory
        """Load a performance history from a file.

        Args:
            file_path: The path to the file.

        Returns:
            The performance history.
        """
        with Path(file_path).open("r") as the_file:
            data = load(the_file)
        values = [
            [
                an_item[PerformanceHistory.PERFORMANCE],
                an_item[PerformanceHistory.INFEASIBILITY]
            ]
            for an_item in data
        ]
        objective_values, infeasibility_measures = zip(*values)
        return PerformanceHistory(objective_values, infeasibility_measures)
