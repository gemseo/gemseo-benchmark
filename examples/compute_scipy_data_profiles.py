from __future__ import print_function

from itertools import product
from numbers import Number

from matplotlib.pyplot import (figure, semilogy, show, title, xlabel, xlim,
                               xticks, ylabel)
from numpy import array, linspace
from numpy.core.multiarray import ndarray
from scipy.optimize import minimize, rosen
from typing import Any, Callable, List

from data_profiles.data_profile import DataProfile
from data_profiles.target_values import TargetValues


def generate_values_history(an_objective,  # type: Callable[[Any], Number]
                            method,  # type: str
                            start_point  # type: ndarray
                            ):  # type: (...) -> List[Number]
    """Minimize a function with a SciPy method and return the objective values
    generated by the minimizer.

    Arguments:
        an_objective: The objective function to minimize.
        method: The name of a SciPy optimization method.
        start_point: The starting point of the algorithm.

    Return:
       The list of successive objective values.

    """
    # Wrap the objective function with a history
    an_objective_history = list()

    def wrapped_objective(x):
        value = an_objective(x)
        an_objective_history.append(value)
        return value

    # Minimize the objective
    minimize(wrapped_objective, start_point, method=method)

    return an_objective_history


# Set the benchmarking problems
objective = rosen
start_points = [array([-2.0, -2.0]),
                array([-2.0, 2.0]),
                array([2.0, -2.0]),
                array([2.0, 2.0]),
                array([0.0, 0.0])]

# Set the reference algorithms
reference_algos = ["slsqp"]

# Generate the reference data
reference_histories = list()
for a_ref_algo, a_start_point in product(reference_algos, start_points):
    objective_history = generate_values_history(objective, a_ref_algo, a_start_point)
    reference_histories.append(objective_history)

# Compute the scale of target values
targets_number = 20
target_values = TargetValues.compute_target_values(reference_histories, targets_number)

print("Target values\n", target_values.tolist())

figure()
title("Target values for Rosenbrock's function")
xlabel("Target index")
xlim([0, targets_number + 1])
xticks(linspace(1, targets_number, dtype=int))
ylabel("Target value")
semilogy(range(1, targets_number + 1), target_values, marker="o", linestyle="")
show()

# Set the algorithms to be compared
methods = ['nelder-mead', 'powell', 'cg', 'bfgs', 'newton-cg',
           'l-bfgs-b', 'tnc', 'cobyla', 'slsqp', 'trust-constr',
           'dogleg', 'trust-ncg', 'trust-exact', 'trust-krylov']
methods.remove("newton-cg")
methods.remove("dogleg")
methods.remove("trust-ncg")
methods.remove("trust-exact")
methods.remove("trust-krylov")

# Compute and plot data profiles
data_profiles = DataProfile({"Rosenbrock": target_values.tolist()})
for a_method in methods:
    histories = [generate_values_history(objective, a_method, a_start_point)
                 for a_start_point in start_points]
    data_profiles.add_values_histories(a_method, {"Rosenbrock": histories})
data_profiles.plot()
