from __future__ import print_function

from itertools import product

from matplotlib.pyplot import (figure, semilogy, show, title, xlabel, xlim,
                               xticks, ylabel)
# noinspection PyUnresolvedReferences
from mpl_toolkits.mplot3d import Axes3D
from numpy import array, linspace
from scipy.optimize import minimize, rosen

from data_profiles.data_profile import DataProfile
from data_profiles.target_values import TargetValues


def generate_values_history(an_objective, method, start_point):
    """Minimize a function with a SciPy method and return the objective values
    generated by the minimizer.

    Arguments:
        an_objective (Callable): the objective function to minimize
        method (str): the name of a SciPy optimization method
        start_point (ndarray): the starting point of the algorithm

    Return:
       (List[Number]) the list of successive objective values

    """
    # Wrap the objective function with a history
    an_objective_history = list()

    def wrapped_objective(x):
        value = an_objective(x)
        an_objective_history.append(value)
        return value

    # Minimize the objective
    minimize(wrapped_objective, start_point, method=method)

    return an_objective_history


# Set the benchmarking problems
objective = rosen
start_points = [array([-2.0, -2.0]),
                array([-2.0, 2.0]),
                array([2.0, -2.0]),
                array([2.0, 2.0]),
                array([0.0, 0.0])]

# Set the reference algorithms
reference_algos = ["slsqp"]

# Generate the reference data
reference_histories = list()
for a_ref_algo, a_start_point in product(reference_algos, start_points):
    objective_history = generate_values_history(objective, a_ref_algo, a_start_point)
    reference_histories.append(objective_history)

# Compute the scale of target values
targets_number = 20
target_values = TargetValues.compute_target_values(reference_histories, targets_number)

print("Target values\n", target_values.tolist())

figure()
title("Target values for Rosenbrock's function")
xlabel("Target index")
xlim([0, targets_number + 1])
xticks(linspace(1, targets_number, dtype=int))
ylabel("Target value")
semilogy(range(1, targets_number + 1), target_values, marker="o", linestyle="")
show()

# Set the algorithms to be compared
methods = ['nelder-mead', 'powell', 'cg', 'bfgs', 'newton-cg',
           'l-bfgs-b', 'tnc', 'cobyla', 'slsqp', 'trust-constr',
           'dogleg', 'trust-ncg', 'trust-exact', 'trust-krylov']
methods.remove("newton-cg")
methods.remove("dogleg")
methods.remove("trust-ncg")
methods.remove("trust-exact")
methods.remove("trust-krylov")

# Compute and plot data profiles
data_profiles = DataProfile({"Rosenbrock": target_values})
for a_method in methods:
    histories = [generate_values_history(objective, a_method, a_start_point)
                 for a_start_point in start_points]
    data_profiles.add_values_histories(a_method, {"Rosenbrock": histories})
data_profiles.plot()
